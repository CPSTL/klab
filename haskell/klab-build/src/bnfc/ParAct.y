-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParAct where
import AbsAct
import LexAct
import ErrM

}

%name pAct Act
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  ':' { PT _ (TS _ 4) }
  ';' { PT _ (TS _ 5) }
  'address' { PT _ (TS _ 6) }
  'behaviour' { PT _ (TS _ 7) }
  'forall' { PT _ (TS _ 8) }
  'if' { PT _ (TS _ 9) }
  'iff' { PT _ (TS _ 10) }
  'int256' { PT _ (TS _ 11) }
  'interface' { PT _ (TS _ 12) }
  'of' { PT _ (TS _ 13) }
  'range' { PT _ (TS _ 14) }
  'storage' { PT _ (TS _ 15) }
  'types' { PT _ (TS _ 16) }
  'uint256' { PT _ (TS _ 17) }
  '{' { PT _ (TS _ 18) }
  '}' { PT _ (TS _ 19) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_Symbol { PT _ (T_Symbol $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
String  :: { String }  : L_quoted {  $1 }
Symbol    :: { Symbol} : L_Symbol { Symbol ($1)}

Act :: { Act }
Act : Header Spec { AbsAct.Act $1 $2 }
Spec :: { Spec }
Spec : Decls ListStorage ListCond { AbsAct.Spec $1 (reverse $2) (reverse $3) }
Type :: { Type }
Type : 'uint256' { AbsAct.Type_uint256 }
     | 'int256' { AbsAct.Type_int256 }
     | 'address' { AbsAct.Type_address }
Arg :: { Arg }
Arg : Type Ident { AbsAct.TypedArg $1 $2 }
ListArg :: { [Arg] }
ListArg : {- empty -} { [] }
        | Arg { (:[]) $1 }
        | Arg ',' ListArg { (:) $1 $3 }
Decl :: { Decl }
Decl : Ident ':' Type { AbsAct.Decl $1 $3 }
ListDecl :: { [Decl] }
ListDecl : {- empty -} { [] }
         | Decl { (:[]) $1 }
         | Decl ';' ListDecl { (:) $1 $3 }
Decls :: { Decls }
Decls : 'forall' '{' ListDecl '}' { AbsAct.DsForall $3 }
      | 'types' '{' ListDecl '}' { AbsAct.DsTypes $3 }
      | {- empty -} { AbsAct.DsEmpty }
Expr :: { Expr }
Expr : Symbol Ident { AbsAct.KSymb $1 $2 }
     | '(' { AbsAct.KLParen }
     | ')' { AbsAct.KRParen }
     | ',' { AbsAct.KComma }
     | Ident { AbsAct.KIdent $1 }
     | Integer { AbsAct.KInt $1 }
     | String { AbsAct.KString $1 }
     | Expr Expr { AbsAct.KTwo $1 $2 }
ListExpr :: { [Expr] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ';' ListExpr { (:) $1 $3 }
Storage :: { Storage }
Storage : 'storage' '{' ListExpr '}' { AbsAct.SThis $3 }
        | Ident 'storage' '{' ListExpr '}' { AbsAct.SThat $1 $4 }
ListStorage :: { [Storage] }
ListStorage : {- empty -} { [] }
            | ListStorage Storage { flip (:) $1 $2 }
Cond :: { Cond }
Cond : 'iff' '{' ListExpr '}' { AbsAct.CIff $3 }
     | Type 'range' '{' ListExpr '}' { AbsAct.CRange $1 $4 }
     | 'if' '{' ListExpr '}' { AbsAct.CIf $3 }
ListCond :: { [Cond] }
ListCond : {- empty -} { [] } | ListCond Cond { flip (:) $1 $2 }
Header :: { Header }
Header : 'behaviour' Ident 'of' Ident 'interface' Ident '(' ListArg ')' { AbsAct.Header $2 $4 $6 $8 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

